#ifndef __FLASH_H
#define __FLASH_H

//#define calibration_Page_63  0x0800FC00 // Последняя страница флеш памяти
// в последних четырех страницах флеш памяти располагается массив данных содержащий телефонные номера абонентов и тексты SMS тревожных сигналов
// запись и чтение ведется в ячейки размером 4-е байта.

// Для записи конфигурации дискретных входов отведена пятая с конца страница флеш памяти (КОНФИГУРАЦИЯ)
#define start_DATA_Page_59  0x0800EC00 // начало пятой с конца страницы флеш памяти, куда будут записываться данные конфигурации входов
#define end_DATA_Page_59    0x0800EFFF // конец пятой с конца страницы флеш памяти, куда будут записываться данные конфигурации входов


// Для записи номеров телефонов целевых абонентов отведена четвертая с конца страница флеш памяти (ТЕЛЕФОННАЯ КНИГА)
#define MAX_SIZE_STR_PHONE_8       32 // максимальный размер строки телефонных номеров ограничиваем 32 байтам (символами)
#define MAX_SIZE_STR_PHONE_32       8 // максимальный размер строки в 32-х словах
#define MAX_NUM_OF_ABONENTS MAX_SIZE_STR_PHONE_8 // максимально возможное число абонентов 32 (32*32 = 1024 - размер одной страницы флеш)

#define start_DATA_Page_60  0x0800F000 // начало четвертой с конца страницы флеш памяти, куда будут записываться данные телефонных номеров целевых абонентов
#define end_DATA_Page_60    0x0800F3FF // конец четвертой с конца страницы флеш памяти, куда будут записываться данные телефонных номеров целевых абонентов

// Для записи пользовательских текстов тревожных SMS о наличии аварийных сигналов на одном из 24 входов выделяется последнии три страницы флеш памяти
#define PAGE_SIZE_8        0x00000400 // размер страницы флеш памяти в байтах (1 килобайт = 1024 байта)
#define PAGE_SIZE_32       0x00000100 // размер страницы флеш памяти в 32-х битных словах (1 килобайт = 256 32-х битных слов)
#define MAX_SIZE_STRING_8          64 // максимальный размер строки ограничиваем 64 байтам (символами), тогда в одну страницу флеш памяти помещается 16 строк
// попарно - две строки на один из 24 входных сигналов.
// первая строка - сообщение о наличии на входе меандра (частота задается в REG74HC165.h)
// вторая строка - сообщение о наличии на входе постоянного активного логического сигнала
#define MAX_SIZE_STR_CELL         128 // размер ячейки содержащей две текстовых строки сообщения для одного цифрового входа
#define STR_CELL_IN_PAGE            8 // число ячеек (по две строки) в одной странице флеш
#define NUM_OF_INPUT_SIGNAL  STR_CELL_IN_PAGE * 3 // число входных сигналов для которых во флеш есть строки с текстами сообщений
#define NUM_OF_MESSAGE    NUM_OF_INPUT_SIGNAL * 2 // на каждый вход приходится по два сообщения
#define MAX_SIZE_STRING_32         16 // максимальный размер строки в 32-х битных словах
#define NUM_OF_CELL_STR            16 // В 1024 байтах одной страницы флеш помещается 16-ть 64 байтных строк текстовых сообщений

#define start_DATA_Page_61  0x0800F400 // начало третей с конца страницы флеш памяти, куда будут записываться текстовые сообщения SMS
#define end_DATA_Page_61    0x0800F7FF // конец третей с конца страницы флеш памяти, куда будут записываться текстовые сообщения SMS

#define start_DATA_Page_62  0x0800F800 // начало второй с конца страницы флеш памяти, куда будут записываться текстовые сообщения SMS
#define end_DATA_Page_62    0x0800FBFF // конец второй с конца страницы флеш памяти, куда будут записываться текстовые сообщения SMS

#define start_DATA_Page_63  0x0800FC00 // начало последней 63-ей страницы флеш памяти, куда будут записываться текстовые сообщения SMS
#define end_DATA_Page_63    0x0800FFFF // конец последней 63-ей страницы флеш памяти, куда будут записываться текстовые сообщения SMS

#define NUM_OF_STR_PAGE     3          // число страниц флеш отведенных под размещение строк текстовых сообщений

// БИТОВОЕ ПОЛЕ СТАТУСА содержит информацию о том, что необходимо записать во FLASH
struct need_write_bf
{
    unsigned phone       : 1; // если 1 то появилась необходимость записи телефонного номера во флеш
    unsigned alarm_text1 : 1; // если 1 то появилась необходимость записи строки тревожного сообщения 1-ого типа во флеш
    unsigned alarm_text2 : 1; // если 1 то появилась необходимость записи строки тревожного сообщения 2-ого типа во флеш
    unsigned alarm_state : 1; // если 1 то появилась необходимость записи конфигурациии входа (что считать активным сигналом: 0 или 1)
    unsigned reserved    : 4; // зарезервированы

};

// Структура описывает текущее состояние подсистемы АЦП
struct Flash_routine_st
{
    struct need_write_bf  need_write; // что потребовалось записать на этот раз

    // для телефонного номера
    uint8_t  abonent_num;   // номер абонента, номер которого подлежит записи во флеш
    uint8_t  phone_num[MAX_SIZE_STR_PHONE_8]; // телефонный номер подлежащий сохранению во флешь
    uint8_t  phone_len;

    // для строк сообщений
    uint8_t  msg_num;   // номер абонента, номер которого подлежит записи во флеш
    uint8_t  Text1[MAX_SIZE_STRING_8]; // текс сообщения типа 1 подлежащий сохранению во флешь
    uint8_t  Text2[MAX_SIZE_STRING_8]; // текс сообщения типа 2 подлежащий сохранению во флешь
    uint8_t  text_len;

    // для конфигурации входов
    //uint8_t  abonent_num;   // номер абонента, номер которого подлежит записи во флеш
    //uint8_t  phone_num[16]; // телефонный номер подлежащий сохранению во флешь

};

extern struct Flash_routine_st Flash_routine_state;

// В каждой странице помещается 8 строк по 128 символов в каждой (максимальная для SMS ограничена 140 8-ми битными символами, но мы их ограничиваем 128 для удобства)
// всего 24 строки на 24 дискретных входа

uint32_t FLASH_Read(uint32_t address); // чтение 32-х битного слова из флеш памяти по заданному адресу

uint8_t FLASH_Read_Byte(uint32_t page, uint16_t byte_shift); // функция чтения одного байта из произвольной страницы флеш памяти по произвольному смещению

uint8_t FLASH_Read_String(uint32_t page, uint32_t shift, uint8_t * data_string, uint32_t size); // функция чтения произвольной строки из флеш

uint8_t FLASH_Read_Msg_String(uint8_t string_cell, uint8_t kind_of_msg, uint8_t * data_string, uint32_t size); // функция чтения строки сообщения из флеш

uint8_t FLASH_Read_Phone_Num(uint8_t string_cell, uint8_t * data_string, uint32_t size); // функция чтения строки телефонного номера целевого абонента из четвертой с конца страницы флеш

int8_t FLASH_Read_Config_Byte(uint16_t byte_shift); // функция чтения байта конфигурации цифровых входов из пятой с конца страницы флеш

// ВНИМАНИЕ!!! Если запись во флешь происходит из прерывания таймера или функции, которая вызывается из прерывании таймера, то на время записи необходимо останавливать таймер

// ВНИМАНИЕ!!! НЕВЕРНОЕ ИСПОЛЬЗОВАНИЕ ЭТОЙ ФУНКЦИИ МОЖЕТ ПОВРЕДИТЬ ПРОШИВКУ!!!
uint8_t FLASH_Write_Byte(uint32_t page, uint16_t byte_shift, uint8_t read_byte); // функция записи одного байта в произвольную страницу флеш памяти по произвольному смещению

// ВНИМАНИЕ!!! НЕВЕРНОЕ ИСПОЛЬЗОВАНИЕ ЭТОЙ ФУНКЦИИ МОЖЕТ ПОВРЕДИТЬ ПРОШИВКУ!!!
uint8_t FLASH_Write_String(uint32_t page, uint32_t shift, uint8_t * data_string, uint32_t size); // функция записи произвольной строки сообщения во флеш

uint8_t FLASH_Write_Msg_String(uint8_t string_cell, uint8_t kind_of_msg, uint8_t * data_string, uint32_t size); // функция записи строки сообщения во флеш в одну из трех последних страниц

uint8_t FLASH_Write_Phone_Num(uint8_t string_cell, uint8_t * data_string, uint32_t size); // функция записи строки телефонного номера целевого абонента в четвертую с конца страницу флеш

uint8_t FLASH_Write_Config_Byte(uint16_t byte_shift, uint8_t config_byte); // функция записи байта конфигурации цифровых входов в пятую с конца страницы флеш

void FLASH_Write_Default_String(void); // функция первоначальной установки текстовых сообщений в строках-ячейках

uint8_t FLASH_Write_Config_Page(uint8_t * config_array, uint8_t size); // функция записи всей конфигурационной страницы цифровых входов в пятую с конца страницы флеш

void FLASH_Write_Default_Config(void); // функция проверки заполнена ли 5-ая по счету с конца страница флеш где хранится конфигурация и если она пуста, запись дефолтной конфигурации

uint8_t FLASH_Write_Page(uint32_t page, uint8_t * data_array, uint8_t size); // функция записи всей страницы неким массивом данных

void WriteDataInFlash(void); // Функция вызывается из обработчика прерывания системного таймера

void SysReset(void); // КОСТЫЛЬ (из-за переполнения ОЗУ при записи во флеш)

#endif /* __FLASH_H */
