#include <stdio.h>
#include "stm32f10x.h"
#include "flash.h"

const uint8_t  std_string_prefix[] = "ALARM ON INPUT "; // префикс строк текстовых сообщений, записываемых по умолчанию если соответствующая строка сообщения в ячеке-строек пуста
const uint32_t DATA_Pages[NUM_OF_STR_PAGE] = { start_DATA_Page_61 , start_DATA_Page_62 , start_DATA_Page_63 };

//***************************************************************************************************************************************
uint32_t FLASH_Read(uint32_t address) // чтение данных из флеш памяти по заданному адресу
{
    return (*(__IO uint32_t*)address);
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция чтения строки сообщения из флеш
// страница флеш памяти разбивается условно на 8-мь 128-и байтных строк-ячеек (как раз 1024 байта - размер одной страницы)
// принимает: 1) адрес страницы флеш памяти
//            2) номер строки-ячейки (их в одной странице 8-мь штук)
//            3) указатель на строку для копирования
//            4) размер копируемой строки
uint8_t FLASH_Read_String(uint32_t page, uint8_t string_cell, uint8_t * data_string, uint32_t size)
{
	int i;

	uint32_t temp_buf[MAX_SIZE_STRING_32];

	if (data_string == NULL)
	{
		return 1;
	}

	if ((page != start_DATA_Page_61) && (page != start_DATA_Page_62) && (page != start_DATA_Page_63))
	{
		return 2;
	}

	if (string_cell > 8)
	{
		return 3;
	}

	if (size > MAX_SIZE_STRING) // если размер строки окажется больше размера страницы обрезаем ее до размера страницы
	{
        size = MAX_SIZE_STRING;
        data_string[MAX_SIZE_STRING-1]='\0'; // и последний символ - нулевой
	}

    // читаем ячеку-строку из флеш
	for (i = 0; i < MAX_SIZE_STRING_32; i++) // чтение идет сразу по 4-е байта
    {
		temp_buf[i] = FLASH_Read(page + MAX_SIZE_STRING * string_cell + 4*i); // сохраняем данные страницы флеш памяти
    }

    strlcpy(data_string, temp_buf, size);
    return 0;
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция записи строки сообщения во флеш
// страница флеш памяти разбивается условно на 8-мь 128-и байтных строк-ячеек (как раз 1024 байта - размер одной страницы)
// принимает: 1) адрес страницы флеш памяти
//            2) номер строки-ячейки (их в одной странице 8-мь штук)
//            3) указатель на записываемую строку
//            4) размер записываемой строки
uint8_t FLASH_Write_String(uint32_t page, uint8_t string_cell, uint8_t * data_string, uint32_t size)
{
	uint32_t i;
	uint32_t temp_buf[PAGE_SIZE_32]; // временный буффер в котором хранятся считанная страница из флеш памяти

	if (data_string == NULL)
	{
		return 1;
	}

	if ((page != start_DATA_Page_61) && (page != start_DATA_Page_62) && (page != start_DATA_Page_63)) // если указана неверная страница флеш
	{
		return 2;
	}

	if (string_cell >= 8)
	{
		return 3;
	}

	if (size > MAX_SIZE_STRING) // если размер строки окажется больше размера ячейки-строки обрезаем ее до размера ячейки-строки
	{
        size = MAX_SIZE_STRING;
        data_string[MAX_SIZE_STRING-1]='\0'; // и последний символ - нулевой
	}

    // читаем страницу флеш во временный буфер
	for (i = 0; i < PAGE_SIZE_32; i++) // чтение идет сразу по 4-е байта
    {
        temp_buf[i] = FLASH_Read(page + 4*i);
    }

	memset(temp_buf + MAX_SIZE_STRING_32 * string_cell, '\0' , MAX_SIZE_STRING );
    memcpy(temp_buf + MAX_SIZE_STRING_32 * string_cell, data_string, strlen(data_string));

    FLASH_ErasePage(page); // стираем страницу флеш памяти

    // записываем измененый временный буфер обратно в страницу флеш
	for (i = 0; i < PAGE_SIZE_32; i++) // запись идет сразу по 4-е байта
    {
		FLASH_ProgramWord(page + 4*i,temp_buf[i]);
    }
	return 0;
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция проверки строк-ячеек на заполненость
// при первом включении устройства контроллер проверяет свои последнии три страницы флеш памяти и при отсутсвии данных в первой строке
// (первый символл соответсвующей строки-ячейки равен 0xFFFFFFFF) заполняет эти страницы дефолтными строками
void FLASH_Write_Default_String(void)
{
	uint8_t i = 0; // перебор страниц флеш
	uint8_t j = 0; // перебор строк ячеек внутри страницы
	uint8_t k = 0; // счетчик записываемых 32-х битных слов
	uint8_t m = 0; // счетчик записаных строк
	uint32_t page;
	uint32_t write_str[MAX_SIZE_STRING];
	uint8_t string_of_num[4]; // строка содержащая номер входного сигнала (маловероятно, что число превысит 3-и порядка)
	//uint32_t temp_buf[PAGE_SIZE_32]; // временный буффер в котором хранятся считанная страница из флеш памяти
	uint8_t string_prefix_size = strlen(std_string_prefix);

	if (0xFFFFFFFF != FLASH_Read(DATA_Pages[0])) // стертая флешь заполняется 0xFFFFFFFF
	{
		return;
	}

    for (i=0; i<NUM_OF_STR_PAGE; i++) // перебераем все страницы флеш отведенные под хранение текстовых сообщений
    {
    	for (j=0; j<NUM_OF_CELL_STR; j++) // перебираем все строки-ячейки в этих cтраницах
    	{
          m++; // условный номер входного сигнала
    	    memset(write_str,'\0',MAX_SIZE_STRING);
    	    memcpy(write_str, std_string_prefix, string_prefix_size);
    	    itoa(m , string_of_num, 10);
    	    strncat(write_str, string_of_num , 4);
    	    strncat(write_str, "\0", 1);
    	    for (k = 0; k < MAX_SIZE_STRING_32; k++)
    	    {
    	        FLASH_ProgramWord(DATA_Pages[i] + MAX_SIZE_STRING*j + 4*k , write_str[k]);
    	    }
    	}
    }
}
//***************************************************************************************************************************************

