#include <stdio.h>
#include "stm32f10x.h"
#include "flash.h"
#include "REG74HC165.h"

const uint8_t  std_string_prefix1[] = "PREALARM ON INPUT "; // префикс строк текстовых сообщений, записываемых по умолчанию если соответствующая строка сообщения в ячеке-строек пуста
const uint8_t  std_string_prefix2[] = "ALARM ON INPUT "; // префикс строк текстовых сообщений, записываемых по умолчанию если соответствующая строка сообщения в ячеке-строек пуста
const uint32_t DATA_Pages[NUM_OF_STR_PAGE] = { start_DATA_Page_61 , start_DATA_Page_62 , start_DATA_Page_63 };

//***************************************************************************************************************************************
uint32_t FLASH_Read(uint32_t address) // чтение данных из флеш памяти по заданному адресу
{
    return (*(__IO uint32_t*)address);
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция чтения одного байта из произвольной страницы флеш памяти по произвольному смещению
// принимает: 1) адрес страницы флеш памяти
//            2) смещение байта начиная с нуля (их в одной странице 1024-е штуки)
//            3) указатель на переменную типа uint8_t, куда будет произведена запись
uint8_t FLASH_Read_Byte(uint32_t page, uint16_t byte_shift, uint8_t * read_byte)
{
	uint32_t byte_shift32;

	union
	{
		uint32_t i32;
		uint8_t  i8[4];
	} temp_buf;

	if (read_byte == NULL)
	{
		return 1;
	}

	if (byte_shift >= PAGE_SIZE_8)
	{
		return 3;
	}

	byte_shift32 = byte_shift - byte_shift%4; // чтение ведется по 4-байта за раз, так что вычитывать будем сразу 4-е с последующим извлечением нужного байта

	// читаем ячеку из флеш
	temp_buf.i32 = FLASH_Read(page + byte_shift32); // сохраняем данные 32-х битной ячейки флеш памяти

	* read_byte = temp_buf.i8[byte_shift%4];
    return 0;
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция чтения произвольной строки из флеш,
// из произвольной страницы, из произвольного адреса внутри страницы
// принимает: 1) адрес страницы флеш памяти
//            2) смещение внутри страницы кратное 4-м байтам
//            (размер страницы 1024 байта, чтение ведется по словами по 4 байта)
//            3) указатель на строку для копирования
//            4) размер копируемой строки
uint8_t FLASH_Read_String(uint32_t page, uint32_t shift, uint8_t * data_string, uint32_t size)
{
	uint32_t i;

	uint32_t temp_buf[MAX_SIZE_STRING_32];

	if (data_string == NULL)
	{
		return 1;
	}

	if ((shift%4) != 0)
	{
	    return 2; // читаемые данные не выровнены на 4-байта
	}

	if (size > PAGE_SIZE_8) // если размер строки окажется больше размера страницы обрезаем ее до размера страницы
	{
        size = PAGE_SIZE_8;
        data_string[PAGE_SIZE_8-1]='\0'; // и последний символ - нулевой
	}

	// читаем ячеку-строку из флеш
	for (i = 0; i < MAX_SIZE_STRING_32; i++) // чтение идет сразу по 4-е байта
    {
		temp_buf[i] = FLASH_Read(page + shift + 4*i); // сохраняем данные страницы флеш памяти
    }

	strlcpy(data_string, temp_buf, size);
    return 0;

}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция чтения строки сообщения из флеш
// страница флеш памяти разбивается условно на 8-мь 128-и байтных ячеек (как раз 1024 байта - размер одной страницы)
// принимает: 1) номер ячейки под пару строк
//            2) признак (0 или 1) - это первое сообщение или второе (например об отсутствии и присутствии сигнала)
//            3) указатель на строку для копирования
//            4) размер копируемой строки
uint8_t FLASH_Read_Msg_String(uint8_t string_cell, uint8_t kind_of_msg, uint8_t * data_string, uint32_t size)
{
	uint32_t page;

	if (data_string == NULL)
	{
		return 1;
	}

	if (string_cell >= NUM_OF_INPUT_SIGNAL)
	{
		return 3;
	}

	page = start_DATA_Page_61;

	if (string_cell >= STR_CELL_IN_PAGE * 2)
	{
	    string_cell -= STR_CELL_IN_PAGE * 2;
	    page = start_DATA_Page_63;
	}

	if (string_cell >= STR_CELL_IN_PAGE)
	{
	    string_cell -= STR_CELL_IN_PAGE;
	    page = start_DATA_Page_62;
	}
    if (kind_of_msg == 0)
    {
    	return FLASH_Read_String(page, MAX_SIZE_STR_CELL * string_cell, data_string, size);
    }
	if (kind_of_msg == 1)
	{
		return FLASH_Read_String(page, MAX_SIZE_STR_CELL * string_cell + MAX_SIZE_STRING_8, data_string, size);
	}
	return 4; // если пользователь указал в типе сообщения не 0 и не 1
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция чтения строки телефонного номера целевого абонента из четвертой с конца страницы флеш
// страница флеш памяти разбивается условно на 32-е 32-ух байтных строк-ячеек (как раз 1024 байта - размер одной страницы)
// принимает: 1) номер строки-ячейки (их в одной странице 32-е штуки)
//            2) указатель на записываемую строку телефонного номера
//            3) размер записываемой строки
uint8_t FLASH_Read_Phone_Num(uint8_t string_cell, uint8_t * data_string, uint32_t size)
{
	if (data_string == NULL)
	{
		return 1;
	}

	if (string_cell >= MAX_SIZE_STR_PHONE_8)
	{
		return 3;
	}

	return FLASH_Read_String(start_DATA_Page_60, MAX_SIZE_STR_PHONE_8 * string_cell, data_string, size);
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция чтения байта конфигурации цифровых входов из пятой с конца страницы флеш
// под каждый вход требуется 1 байт в котором будет хранится битовое поле конфигурации
// принимает: 1) номер байта начиная с нуля (их в одной странице 1024-е штуки)
//            2) указатель на записываемую структуру конфигурации
uint8_t FLASH_Read_Config_Byte(uint16_t byte_shift, uint8_t * config_byte)
{
	if (config_byte == NULL)
	{
		return 1;
	}

	if (byte_shift >= PAGE_SIZE_8)
	{
		return 3;
	}

	return FLASH_Read_Byte(start_DATA_Page_59, byte_shift, config_byte);
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// ВНИМАНИЕ!!! НЕВЕРНОЕ ИСПОЛЬЗОВАНИЕ ЭТОЙ ФУНКЦИИ МОЖЕТ ПОВРЕДИТЬ ПРОШИВКУ!!!
// функция записи одного байта в произвольную страницу флеш памяти по произвольному смещению
// принимает: 1) адрес страницы флеш памяти
//            2) смещение байта начиная с нуля (их в одной странице 1024-е штуки)
//            3) указатель на переменную типа uint8_t, из которой будет произведена запись
uint8_t FLASH_Write_Byte(uint32_t page, uint16_t byte_shift, uint8_t write_byte)
{
	uint32_t i;

	uint32_t byte_shift32;

	union
	{
		uint32_t i32;
		uint8_t  i8[4];
	} temp_buf[PAGE_SIZE_32];

	if (write_byte == NULL)
	{
		return 1;
	}

	if (byte_shift >= PAGE_SIZE_8)
	{
		return 3;
	}

	byte_shift32 = byte_shift - byte_shift%4; // запись ведется по 4-байта за раз, так что вычитывать будем сразу 4-е с последующим извлечением нужного байта

    // читаем страницу флеш во временный буфер
	for (i = 0; i < PAGE_SIZE_32; i++) // чтение идет сразу по 4-е байта
    {
        temp_buf[i].i32 = FLASH_Read(page + 4*i);
    }

	temp_buf[byte_shift - byte_shift%4].i8[byte_shift%4] = write_byte; // изменяем данные

	FLASH_ErasePage(page); // стираем страницу флеш памяти

	// записываем измененый временный буфер обратно в страницу флеш
    for (i = 0; i < PAGE_SIZE_32; i++) // запись идет сразу по 4-е байта
	{
	    FLASH_ProgramWord(page + 4*i,temp_buf[i].i32);
	}

    return 0;
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// ВНИМАНИЕ!!! НЕВЕРНОЕ ИСПОЛЬЗОВАНИЕ ЭТОЙ ФУНКЦИИ МОЖЕТ ПОВРЕДИТЬ ПРОШИВКУ!!!
// функция записи произвольной строки сообщения во флеш
// в произвольную страницу, по произвольному адресу
// произвольной длины (но не больше длины страницы)
// принимает: 1) адрес страницы флеш памяти
//            2) смещение внутри страницы кратное 4-м байтам
//            (размер страницы 1024 байта, чтение ведется по словами по 4 байта)
//            3) указатель на строку для копирования
//            4) размер копируемой строки
uint8_t FLASH_Write_String(uint32_t page, uint32_t shift, uint8_t * data_string, uint32_t size)
{
	uint32_t i;

	uint32_t temp_buf[PAGE_SIZE_32]; // временный буффер в котором хранятся считанная страница из флеш памяти

	if (data_string == NULL)
	{
		return 1;
	}

	if ((shift%4) != 0)
	{
	    return 2; // записываемые данные не выровнены на 4-байта
	}

	if (size > PAGE_SIZE_8) // если размер строки окажется больше размера страницы
	{
        size = PAGE_SIZE_8 - 1;
	}

    // читаем страницу флеш во временный буфер
	for (i = 0; i < PAGE_SIZE_32; i++) // чтение идет сразу по 4-е байта
    {
        temp_buf[i] = FLASH_Read(page + 4*i);
    }

	memset(temp_buf + shift/4, '\0' , size + 1);
    memcpy(temp_buf + shift/4, data_string, size);

    FLASH_ErasePage(page); // стираем страницу флеш памяти

    // записываем измененый временный буфер обратно в страницу флеш
	for (i = 0; i < PAGE_SIZE_32; i++) // запись идет сразу по 4-е байта    PAGE_SIZE_32
    {
		FLASH_ProgramWord(page + 4*i,temp_buf[i]);
    }


//    for (k = 0; k < MAX_SIZE_STRING_32; k++)
//    {
//        FLASH_ProgramWord(DATA_Pages[i] + MAX_SIZE_STRING_8*j + 4*k , write_str[k]);
//    }



	return 0;
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция записи строки сообщения во флеш в одну из трех последних страниц
// страница флеш памяти разбивается условно на 8-мь 128-и байтных ячеек (как раз 1024 байта - размер одной страницы)
// принимает: 1) номер ячейки под пару строк
//            2) признак (0 или 1) - это первое сообщение или второе (например об отсутствии и присутствии сигнала)
//            3) указатель на записываемую строку
//            4) размер записываемой строки
uint8_t FLASH_Write_Msg_String(uint8_t string_cell, uint8_t kind_of_msg, uint8_t * data_string, uint32_t size)
{
	uint32_t page;

	if (data_string == NULL)
	{
		return 1;
	}

	if (string_cell >= NUM_OF_INPUT_SIGNAL)
	{
		return 3;
	}

	page = start_DATA_Page_61;

	if (string_cell >= STR_CELL_IN_PAGE * 2)
	{
	    string_cell -= STR_CELL_IN_PAGE * 2;
	    page = start_DATA_Page_63;
	}

	if (string_cell >= STR_CELL_IN_PAGE)
	{
	    string_cell -= STR_CELL_IN_PAGE;
	    page = start_DATA_Page_62;
	}

	if (size > MAX_SIZE_STRING_8) // если размер строки окажется больше максимального размера строки обрезаем ее до этого размера
	{
        size = MAX_SIZE_STRING_8;
        data_string[MAX_SIZE_STRING_8-1]='\0'; // и последний символ - нулевой
	}
    if (kind_of_msg == 0)
    {
    	return FLASH_Write_String(page, MAX_SIZE_STR_CELL * string_cell, data_string, size);
    }
	if (kind_of_msg == 1)
	{
		return FLASH_Write_String(page, MAX_SIZE_STR_CELL * string_cell + MAX_SIZE_STRING_8, data_string, size);
	}
	return 4; // если пользователь указал в типе сообщения не 0 и не 1
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция записи строки телефонного номера целевого абонента в четвертую с конца страницу флеш
// страница флеш памяти разбивается условно на 32-е 32-ух байтных строк-ячеек (как раз 1024 байта - размер одной страницы)
// принимает: 1) номер строки-ячейки (их в одной странице 32-е штуки)
//            2) указатель на записываемую строку телефонного номера
//            3) размер записываемой строки
uint8_t FLASH_Write_Phone_Num(uint8_t string_cell, uint8_t * data_string, uint32_t size)
{
	if (data_string == NULL)
	{
		return 1;
	}

	if (string_cell >= MAX_SIZE_STR_PHONE_8)
	{
		return 3;
	}

	if (size > MAX_SIZE_STR_PHONE_8) // если размер строки окажется больше размера ячейки-строки обрезаем ее до размера ячейки-строки
	{
        size = MAX_SIZE_STR_PHONE_8;
        data_string[MAX_SIZE_STR_PHONE_8-1]='\0'; // и последний символ - нулевой
	}

	return FLASH_Write_String(start_DATA_Page_60, MAX_SIZE_STR_PHONE_8 * string_cell, data_string, size);
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция записи байта конфигурации цифровых входов в пятую с конца страницы флеш
// под каждый вход требуется 1 байт в котором будет хранится битовое поле конфигурации
// принимает: 1) номер байта начиная с нуля (их в одной странице 1024-е штуки)
//            2) указатель на записываемую структуру конфигурации
uint8_t FLASH_Write_Config_Byte(uint16_t byte_shift, uint8_t config_byte)
{
	if (config_byte == NULL)
	{
		return 1;
	}

	if (byte_shift >= PAGE_SIZE_8)
	{
		return 3;
	}

	return FLASH_Write_Byte(start_DATA_Page_59, byte_shift, config_byte);
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция проверки строк-ячеек на заполненость
// при первом включении устройства контроллер проверяет свои последнии три страницы флеш памяти и при отсутсвии данных в первой строке
// (первый символл соответсвующей строки-ячейки равен 0xFFFFFFFF) заполняет эти страницы дефолтными строками
void FLASH_Write_Default_String(void)
{
	uint8_t i = 0; // перебор страниц флеш
	uint8_t j = 0; // перебор строк ячеек внутри страницы
	uint8_t k = 0; // счетчик записываемых 32-х битных слов
	uint8_t m = 1; // счетчик записаных строк
	uint32_t page;
	uint32_t write_str[MAX_SIZE_STRING_32];
	uint8_t string_of_num[4]; // строка содержащая номер входного сигнала (маловероятно, что число превысит 3-и порядка)
	//uint32_t temp_buf[PAGE_SIZE_32]; // временный буффер в котором хранятся считанная страница из флеш памяти
	uint8_t string_prefix_size1 = strlen(std_string_prefix1);
	uint8_t string_prefix_size2 = strlen(std_string_prefix2);

	if (0xFFFFFFFF != FLASH_Read(DATA_Pages[0])) // стертая флешь заполняется 0xFFFFFFFF
	{
		return;
	}

    for (i=0; i<NUM_OF_STR_PAGE; i++) // перебераем все страницы флеш отведенные под хранение текстовых сообщений
    {
    	for (j=0; j < NUM_OF_CELL_STR; j++) // перебираем все строки-ячейки в этих cтраницах
    	{
    		memset(write_str,'\0',MAX_SIZE_STRING_8);
    		if(j%2)
            {
    			memcpy(write_str, std_string_prefix1, string_prefix_size1);
    			itoa(m , string_of_num, 10);
    			m++; // условный номер входного сигнала
            }
    		else
    		{
    			memcpy(write_str, std_string_prefix2, string_prefix_size2);
    			itoa(m , string_of_num, 10);
			}
    	    strncat(write_str, string_of_num , 4);
    	    strncat(write_str, "\0", 1);
    	    for (k = 0; k < MAX_SIZE_STRING_32; k++)
    	    {
    	        FLASH_ProgramWord(DATA_Pages[i] + MAX_SIZE_STRING_8*j + 4*k , write_str[k]);
    	    }
    	}
    }
}
//***************************************************************************************************************************************

//***************************************************************************************************************************************
// функция проверки заполнена ли 5-ая по счету с конца страница флеш где хранится конфигурация и если она пуста, запись дефолтной конфигурации
// при первом включении устройства контроллер проверяет свои последнии три страницы флеш памяти и при отсутсвии данных в первой строке
// (первый символл соответсвующей строки-ячейки равен 0xFFFFFFFF) заполняет эти страницы дефолтными строками
void FLASH_Write_Default_Config(void)
{
	uint8_t i = 0; // перебор страниц флеш
	uint8_t j = 0; // перебор строк ячеек внутри страницы
	uint8_t k = 0; // счетчик записываемых 32-х битных слов
	uint8_t m = 0; // счетчик записаных строк
	uint32_t page;
	uint32_t write_str[MAX_SIZE_STRING_8];
	uint8_t string_of_num[4]; // строка содержащая номер входного сигнала (маловероятно, что число превысит 3-и порядка)

	if (0xFFFFFFFF != FLASH_Read(start_DATA_Page_59)) // стертая флешь заполняется 0xFFFFFFFF
	{
		return;
	}

    for (i=0; i<NUM_OF_INPUT; i++) // перебераем столько ячеек страницы конфигурации цифровых входов во флеш сколько имеем входов
    {
    	FLASH_Write_Config_Byte(i, 0); // пока все по нулям
    }
}
//***************************************************************************************************************************************
