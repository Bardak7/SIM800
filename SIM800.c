#include <stdio.h>
#include "phisic.h"
#include "stm32f10x.h"
#include "stm32f10x_gpio.h"
#include "SIM800.h"

// Отправка данных в UART на котором сидит SIM800
void PutsToSim800(const char *cmd)
{
	send_str_uart2rn(cmd); // выводим данные в UART с добавлением завершающих символов \n\r
}

// Функция проверки и поиска ответа от SIM800
// принимает указатель на строку с проверяемым сообщением
// возвращает индекс начала строки следующей за проверенной строкой или -1 если искомая строка не найдена
int8_t Sim800_CompareStr(const char *string)
{
    uint8_t len;
    len = strlen(string);
//	strstr(rec_buf_usart2 , string);
}

// Функция отправки команды в модуль Sim800
void Sim800_WriteCmd(const char *cmd)
{
    PutsToSim800(cmd); // Отправка данных в UART на котором сидит SIM800
}

// Функция отправки команды в модуль Sim800 с проверкой ответа (блокирующийся вариант)
void Sim800_WriteCmd_confirm(const char *cmd)
{
    PutsToSim800(cmd); // Отправка данных в UART на котором сидит SIM800
    return Sim800_CompareStr("\r\nOK"); // Функция чтения данных с порта UART с проверкой выполнения
}

// Функция инициализации модуля SIM800
uint8_t sim800_init(uint8_t init_data)
{

}

// Главная функция отправки запросов, получения и обработки ответов SIM800
// Содержит в себе весь алгоритм отправки запросов и получения ответов от SIM800
// Может вызываться как из основной программы, так и из прерывания
//
// Типичный алгоритм запроса представляет из себя следующее:
// 1) Отправили запрос из основного кода программы вызвав эту функцию и передав ей указатель
// содержащий строку команды
// 2) SIM800 получил запрос и выполняет его с последующим ответом
// 3) При приеме очередного символа по UART на котором сидит SIM800 вызывается та же функция
// но уже не как простой вызов, а как callback из прерывания, причем т.к. теперь данная функция
// вызывается не для отправки команды, то в этом параметре передаем NULL
// 4) в этой функции проверяется окончание транзакции
// 5) Если транзакция завершена (получен полный ответ), производим обработку этого ответа и
// 6) Сообщаем о результатах первоначально вызвавшему коду опять через callback, но уже на
// вызывающий код
// Принимает: 1) указатель на строку содержащую команду
//            2) данные полученные из прерывания по приему сивола от SIM800
//            3) указатель на буфер где должны будут сложены принимаемые данные после обработки полученного от SIM800 ответа
//            4) хитрый финт ушами - указатель (callback) на функцию, которая вызвала sim800_routine с целью достучаться до SIM800
//               это нужно для того, что бы после получения ответа передать управление обратно в вызвавшую функцию, что бы она разобрала полученный
//               на ее запрос ответ. Самое важное, что такое отсроченное выполнение функции дает возможность не блокировать остальной код
// Возвращает статус занят не занят
int8_t sim800_routine(const char *cmd, uint8_t rec_uart_char, const uint8_t response_data, void (*callback)(int32_t *))
{
    static char current_cmd[CURRENT_CMD_SIZE]; // буффер для текущей обрабатываемой SIM800 команды
	static uint8_t is_busy; // признак "занят / не занят", если функция отправила запрос, но еще не получила ответа от модуля SIM800, то is_busy = busy
//                                                                                                                    в противном случае is_busy = free
    static char rec_buf[REC_BUF_SIZE]; // приемный буфер, куда будет складываться ответ от SIM800
    static uint8_t current_pos; // текущая позиция последнего принятого символа в приемном буфере
    static void (*cur_callback)(int32_t *); // текущий колбек для последующего вызова вызвавшей нас функции
    static uint8_t is_responce; // флаг для того, что бы (если включен режим ЭХО у SIM800) отличать внезапные сообщения от ответов на заданные запросы
    //int8_t parsing_result;  // результат разбора полученного ответа

	if ( cmd != NULL ) // если вызвали не из прерывания, т.е. хотим отправить команду или запрос из основной программы
    {
    	if (is_busy == busy) // Если еще не получен ответ на предидущий запрос или команду
    	{
            return busy; // Возвращаем признак занятости и ни чего не делаем
    	}
    	else // если обработка предыдущей команды закончена и функция свободна, то
    	{
		    is_busy = busy; // Выставляем флаг "занят"
		    memset(current_cmd, 0, sizeof(current_cmd)); //очищаем предидущую обработанную команду
		    strcpy(current_cmd, cmd); // запоминаем команду (нам она может потребоваться при обработке ответа на нее)
		    is_responce = no; // сбрасываем флаг, что дальше будут только данные ответа на наш запрос
		    Sim800_WriteCmd(cmd); // и отправляем команду в SIM800
		    return 0; // Возвращаемся в вызвавший код сигнал ждать ответа и заниматься другими делами
    	}

    }
    else // если нас вызвали из прерывания
    {
    	rec_buf[current_pos] = rec_uart_char; // заносим принятые данные в приемный буфер
    	current_pos++; // инкрементируем текущую позицию в приемном буфере для сохранения следующего символа
    	if (current_pos > REC_BUF_SIZE - 1)
    	{
    		// В случае переполнения леквидируем полученный ответ
    		current_pos = 0;
    	}

    	if (current_pos > 3) // если в приемном буфере больше 3-х символов
    	{
    		// теперь надо проверить приемный буфер на наличие либо заветных \r\r\n (признак конца эхо отправленной команды
    		// если включен соответствующий режим)
    		// либо заветных \r\n (признака конца ответа полученного от модуля SIM800)
    		if ((rec_buf[current_pos - 1] == '\n') && (rec_buf[current_pos - 2] == '\r'))
	    	{
	    		is_busy = busy;
	    		if (rec_buf[current_pos - 3] == '\r') // значит SIM800 работает в режиме ЭХО и скорее всего получена исходная команда, отправленная нами в начале транзакции
	    		{
        			//теперь надо проверить, а это точно ответ на наш запрос (совподает ли отправленная команда с полученным ЭХО)
        			if (strstr(rec_buf ,current_cmd) != NULL)
        			{
        				// если да, то спокойно переводим текущую позицию приемного буфера в начало, тем самым выкинув ЭХО из последующих проверок
        				//(новые данные будут записываться поверх старых)
        				current_pos = 0;
        				// необходимо еще выставить флаг, что все дальнейшие получаемые данные до следующей последовательности символов \r\n - это точно
        				// ответ на выданный запрос, а не внезапное сообщение например о пришедшем SMS
        				is_responce = yes;
        			} // если же нет, то возможно это еще какой-то полезный ответ
        			else // вставляем тогда вместо первого \r символ конца строки \0 (в конце было \r\r\n станет \0\r\n)
        			{
        				rec_buf[current_pos - 3] = '\0';
        				unexpec_message_parse(); // вызываем функцию разбора внезапных сообщений
    				}
        		}
        		else // если пришло сообщение с \r\n в конце, то это не ЭХО и мы должны извлеч команду из приемного буфера и отдать ее на парсинг
        		{
        			// для этого вставляем вместо первого \r символ конца строки \0 (в конце было \r\n станет \0\n)
        			rec_buf[current_pos - 2] = '\0';
        			if (is_responce == yes) // если до этого уже пришло ЭХО отправленной команды, то это ответ на нее
        		    {
        		    	memcpy(response_data, rec_buf, current_pos - 2); // Копируем данные из приемного буфера в буфер, который нам был указан вызывающей функцией
        				cur_callback(NULL); // вызываем повторно ту самую функцию, которая нас вызвала, на этот раз все готово для ее окончательного выполнения
        		        // NULL как раз !!!!!!!!!!!!!!!
        		    }
        		    else // если же это внезапное сообщение, например о приходе SMS то
        		    {
        		    	unexpec_message_parse(rec_buf); // вызываем функцию разбора внезапных сообщений
        		    }


        		    // и отправляем полученную строку на парсинг указав буфер в который должен быть положены сопутствующие данные (если таковые имеются)
        		    sim800_parsing_response(rec_buf, response_data);
        		}
        	    current_pos = 0; // сбрасываем позицию внутри буфера в ноль, для новых посылок от SIM800
        	    is_busy = free; // в конце обработки запроса выставляем флаг "свободно"
        	    return parsing_result;

            }
    	}

    	//if () // если пришла SMS или другое внезапное сообщение от SIM800 не являющееся ответом на полученный запрос
    	//{
    	      // обрабатываем его
        //}


    	//is_busy = free; // в конце обработки запроса выставляем флаг "свободно"
	}
}

// Функция отправки SMS с модуля SIM800
uint8_t sim800_sendSMS(uint8_t* text_buf, uint8_t length)
{

}

// Функция включения модуля SIM800
void sim800_PWRKEY_on(void)
{
	// Подаем на порт PWRKEY лог. 0
	GPIO_WriteBit (GPIO_SIM800_PWRKEY, SIM800_PWRKEY, Bit_RESET);
	// Задержка в мс., необходимая для включения
	DelayMs(2000);

	// Подаем на порт PWRKEY лог. 1
	GPIO_WriteBit (GPIO_SIM800_PWRKEY, SIM800_PWRKEY, Bit_SET);
	// Ожидаем включение/выключение SIM800
	DelayMs(4000);

}
